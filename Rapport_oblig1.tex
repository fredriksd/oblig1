\documentclass[11pt, a4paper]{article}

\usepackage[T1]{fontenc} 								
\usepackage[norsk]{babel}								
\usepackage[utf8]{inputenc}						
\usepackage{graphicx}       						
\usepackage{amsmath,amssymb}
\usepackage{grffile}

\setcounter{secnumdepth}{0}

\setlength{\textheight}{240mm} 
\setlength{\textwidth}{180mm}  
\topmargin -5mm 
\oddsidemargin -5mm

\begin{document}
\title{Hastighet til lekebil ned skråplan}
\author{Fredrik Sandhei}
\date{\today}
\maketitle
\footnote{AUT-1001, UiT. Obligatorisk innlevering 1}
\newpage
\tableofcontents
\newpage

\section{Introduksjon}
%%Nevn bruk av atmega 16, stk-500 osv
%%Prosjekt for å sjekke hastigheten på bilen opp mot "tidløse" formel

\section{Hensikt}
Hensikten med denne oppgaven var å undersøke gyldigheten til den såkalte 'tidsløse formelen' $ 2as = v^{2} - v_{0}^{2} $ med hjelp av sensorer for å måle tiden, og dermed hastigheten til lekebilen og sjekke den opp mot teorien.

\section{Teori}
Fra fysikken har man ved hjelp av tiden $t$ og akselerasjonen $a$ muligheten til å finne et uttrykk for hastigheten $v$ til et objekt som beveger seg. Ved hjelp av integrasjon av (\ref{hastighet}) får en uttrykt strekning avlagt $x$ ved tiden $t$.

\begin{equation} \label{hastighet}
v = v_{0} + at
\end{equation}
\begin{equation} \label{strekning}
x = x_{0} + v_{0}t + \frac{1}{2}at^{2}
\end{equation}
Substituerer man t fra (\ref{hastighet}) og setter den inn i (\ref{strekning})får man hastigheten uttrykt uavhengig av tid.

\begin{equation}
2as = v^{2}-v_{0}^{2} \implies v^{2} = 2as-v_{0}^{2}
\end{equation}
\newline

I dette tilfellet skulle bilen rulle ned et skråplan med en fritt bestemt helning $\alpha$. Akselerasjonen til bilen blir bestemt ut i fra tyngdeakselerasjonen samt vinkelen mellom relativ bevegelsesretning og horisontal akse, og er dermed gitt ved $a = gsin \alpha$. Fra uttrykket og figuren under er det klart at ved høyere vinkel ($0^\circ \leq\alpha\leq 90^\circ$) får en høyere akselerasjon og dermed høyere hastighet.\newline

For å kunne måle hastigheten kan en ved hjelp av eksterne interrupts koblet til tre IR-sensorer og timer/counter finne tiden det tar for at lekebilen bryter to IR-lyssensorer.
Hensikten med å bruke interrupts er at de stopper opp programmet som mikrokontrolleren kjører og gjennomfører en Interrupt Service Protocol (ISP) dersom det er en tilstandsendring som oppstår.\newline For denne problemstillinga ble det brukt en 16-bits timer, timer1, som kan telle, tilbakestilles og stoppes, men brukes også i sammenheng med ICP - Input Capture Pin - for å måle tiden mellom to logiske nivåendringer. 
Sensor $S_{1}$ er koblet til pd2 på mikrokontrolleren, som har INT0(External Interrupt 0) som spesialfunksjon. Når pin 2 på port D blir satt høy, blir en ISP for INT0 gjennomført. Når INT0 er aktiv, settes i gang timer1. Når ICP på pin 6 på port D, som er koblet til sensorene $S_{2}$ og $S_{3}$ går høy, blir timeren tilbakestilt, i tillegg til eventuelle overflows (antall ganger klokken har passert maksverdi - 65536). Tida det går fra timeren er tilbakestilt og en ending edge blir registrert i Input Capture - registeret, blir da tida det tok å passere $S_{2}$ og $S_{3}$, som har en avstand på 10cm.\newline Da 16-bits timeren går på samme klokkefrekvens som mikrokontrollerens prosessor ($F_{CPU} = 3686400 Hz$), er det praktisk å senke hastigheten til timer-klokka. Dette oppnås ved prescalers, der klokkehastigheten kan enten reduseres med en 8,64,256,1024-divider. 


\section{Løsning}
\subsection{Tankegang}
Ved hjelp av den eksterne interrupten INT0 kan man lage en tilstandsmaskin, der mikrokontrolleren gjennomfører ulike operasjoner gitt av ISP basert på tilstanden den er i. Tilstanden endres ved hjelp av de ulike sensorene. På denne måten vil ikke en ny tid bli målt før bilen passerer $S_{1}$ på nytt. Dessuten blir det også lettere å skrive koden, da man må bare lete etter hvilken tilstand mikrokontrolleren er i ved gitt tidspunkt. 

\subsection{Implementering}
Utgangspunktet for tilstandsmaskinen er følgende: Registrer at bilen er i bevegelse. Start timer1 og telle fram til $S_{2}$. Ved $S_{2}$, nullstill overflow-telleren $ov_counter$ og timer1 $TCNTR1$, men fortsette å telle, og endre tilstandsvariabelen($running = 2;$). I denne tilstanden vil mikrokontrolleren vente til en ending edge oppstår, og legger til antall klokketikker fra overflowene dersom det var noen. Ettersom $clocks$ - variabelen finner antall klokketikker siden den siste ending edge, dvs siste gang ICP ble høy, blir tiden det tok fra $S_{2}$ og $S_{3}$ å dividere $clocks$ på timer1-frekvensen. Hastigheten blir da beregnet med $v = s/t$, der $ s = distance = 1000mm$. \newline
%
Resultanthastigheten skrives så ut på en skjerm gjennom void-funksjonen $displaySpeed()$, med hastigheten som argument. Da output på skjermen var regulert ved å sette relaterte bits til de ulike ledlysene høy, blir det komplisert å innblande floats/desimaltall. Dessuten blir det mindre minne å bruke, da denne datatypen bruker 64 bits, i motsetning til int på 16 bits. Derfor ble hastigheten økt med graden 10. Det første sifferet blir da hastighet heltallsdividert på 10, og det siste sifferet hastighet modulo 10. 

%Finn ut navnet på displayet.
%Legg til bilde av display for eksempel.

\section{Testing}
I denne seksjonen vises testresultaten med ulik $\alpha$ satt opp mot den teoretiske (gjennom (\ref{hastighet})) og den praktiske. Da vinkelen ikke er nøyaktig ønsket vinkel, blir det en liten feilkilde på $\pm 0.1m/s$ (? sjekk ut hvor mye?). Merk notasjonen for klokkefrekvens med prescaler 8 og 1024. 
%Sjekk for \alpha ≈ 30, 45, 60.
%Sjekk for teoretisk hastighet. 

\begin{table}[h]
\caption{Teoretisk hastighet mot praktisk hastighet med ulike $\alpha$ og $F_{CPU_{8}}$}
\begin{center}
\begin{tabular}{ccccc}
\hline
Vinkel ($\alpha$)  & Teoretisk ($ v =\sqrt{2as}$) &  Praktisk\\
\hline

$\alpha = 30^{\circ}\rm$ & t1 & ($p1 \pm 0.1) m/s \rm$\\

$\alpha = 45^{\circ}\rm$ & t2 & ($p2 \pm 0.1) m/s \rm $ \\

$\alpha = 60^{\circ}\rm$ & t3 & ($p3 \pm 0.1) m/s \rm $ \\

\hline

\end{tabular}
\end{center}
\end{table}

\begin{table}[h]
\caption{Teoretisk hastighet mot praktisk hastighet med ulike $\alpha$ og $F_{CPU_{1024}}$}
\begin{center}
\begin{tabular}{ccccc}
\hline
Vinkel ($\alpha$)  & Teoretisk ($ v =\sqrt{2as}$) &  Praktisk\\
\hline

$\alpha = 30^{\circ}\rm$ & t1 & ($p1 \pm 0.1) m/s \rm$\\

$\alpha = 45^{\circ}\rm$ & t2 & ($p2 \pm 0.1) m/s \rm $ \\

$\alpha = 60^{\circ}\rm$ & t3 & ($p3 \pm 0.1) m/s \rm $ \\

\hline
\end{tabular}
\end{center}
\end{table}



\section{Resultater}
%Skriv om hastigheten, hvor stor forskjell er det mellom de, og ca hvor stor blir usikkerheten. 
\section{Diskusjon}
%Hva 'gikk galt'? M.a.o., hva gjorde eventuelt at hastigheten ble så forskjellige ved de ulike vinklene? 
%Ble de korrekte, eller med en viss mengde avvik?

\end{document}

